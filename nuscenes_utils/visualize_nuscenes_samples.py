#!/usr/bin/env python3
"""
Script to read and visualize range images generated by sample_nuscenes_dataset.py
"""

import numpy as np
import matplotlib.pyplot as plt
import argparse
import os
import glob
from pathlib import Path


def load_range_image(file_path):
    """Load a range image from .npy file"""
    if not os.path.exists(file_path):
        raise FileNotFoundError(f"File not found: {file_path}")
    
    data = np.load(file_path, allow_pickle=True)
    print(f"Loaded range image from: {file_path}")
    
    # Handle different output formats from NuScenesPointCloudToRangeImage
    if isinstance(data, np.ndarray):
        if data.ndim == 2:
            # This is the actual format from NuScenesPointCloudToRangeImage when add_channel_dim=False
            # Data is concatenated as [range_img, intensity_img] horizontally
            H, W_total = data.shape
            W = W_total // 2  # Each channel has width W
            
            range_data = data[:, :W]
            intensity_data = data[:, W:]
            
            print(f"Shape: {data.shape} (concatenated: range + intensity)")
            print(f"Individual channel shape: {range_data.shape}")
            print(f"Data type: {data.dtype}")
            print(f"Range values: [{range_data.min():.3f}, {range_data.max():.3f}]")
            print(f"Intensity values: [{intensity_data.min():.3f}, {intensity_data.max():.3f}]")
            
            return {
                "range": range_data,
                "intensity": intensity_data,
                "mask": np.ones((H, W), dtype=np.uint8)
            }
        elif data.ndim == 3:
            if data.shape[2] == 2:
                # Old format: [range, intensity]
                print(f"Shape: {data.shape} (2-channel: range, intensity)")
                print(f"Data type: {data.dtype}")
                print(f"Range values: [{data[:,:,0].min():.3f}, {data[:,:,0].max():.3f}]")
                print(f"Intensity values: [{data[:,:,1].min():.3f}, {data[:,:,1].max():.3f}]")
                return {"range": data[:,:,0], "intensity": data[:,:,1], "mask": np.ones(data.shape[:2], dtype=np.uint8)}
            elif data.shape[2] == 3:
                # New format: [range, intensity, mask]
                print(f"Shape: {data.shape} (3-channel: range, intensity, mask)")
                print(f"Data type: {data.dtype}")
                print(f"Range values: [{data[:,:,0].min():.3f}, {data[:,:,0].max():.3f}]")
                print(f"Intensity values: [{data[:,:,1].min():.3f}, {data[:,:,1].max():.3f}]")
                print(f"Mask values: [{data[:,:,2].min()}, {data[:,:,2].max()}]")
                return {"range": data[:,:,0], "intensity": data[:,:,1], "mask": data[:,:,2]}
            else:
                print(f"Warning: Unexpected 3D shape: {data.shape}")
                return {"range": data[:,:,0], "intensity": data[:,:,1], "mask": np.ones(data.shape[:2], dtype=np.uint8)}
        else:
            print(f"Warning: Unexpected shape: {data.shape}")
            return {"range": data, "intensity": np.zeros_like(data), "mask": np.ones_like(data, dtype=np.uint8)}
    elif isinstance(data, dict):
        # Dictionary format
        print(f"Shape: {data['range'].shape} (dictionary format)")
        print(f"Data type: {data['range'].dtype}")
        print(f"Range values: [{data['range'].min():.3f}, {data['range'].max():.3f}]")
        print(f"Intensity values: [{data['intensity'].min():.3f}, {data['intensity'].max():.3f}]")
        if 'mask' in data:
            print(f"Mask values: [{data['mask'].min()}, {data['mask'].max()}]")
        return data
    else:
        print(f"Warning: Unexpected data type: {type(data)}")
        return {"range": data, "intensity": np.zeros_like(data), "mask": np.ones_like(data, dtype=np.uint8)}


def visualize_range_image(data, title="Range Image", save_path=None):
    """Visualize range image with multiple views"""
    # Handle different data formats
    if isinstance(data, dict):
        range_data = data['range']
        intensity_data = data['intensity']
        mask_data = data.get('mask', np.ones_like(range_data, dtype=np.uint8))
    else:
        # Fallback for old format
        range_data = data[:, :, 0]
        intensity_data = data[:, :, 1]
        mask_data = np.ones_like(range_data, dtype=np.uint8)
    
    # Create figure with multiple subplots
    fig, axes = plt.subplots(2, 2, figsize=(16, 12))
    
    # Range channel
    im1 = axes[0,0].imshow(range_data, cmap='viridis', aspect='auto')
    axes[0,0].set_title(f'Range Channel\n[{range_data.min():.3f}, {range_data.max():.3f}]', fontsize=12)
    axes[0,0].set_xlabel('Azimuth (columns)', fontsize=10)
    axes[0,0].set_ylabel('Elevation (rows)', fontsize=10)
    plt.colorbar(im1, ax=axes[0,0], label='Range (m)')
    
    # Intensity channel
    im2 = axes[0,1].imshow(intensity_data, cmap='plasma', aspect='auto')
    axes[0,1].set_title(f'Intensity Channel\n[{intensity_data.min():.3f}, {intensity_data.max():.3f}]', fontsize=12)
    axes[0,1].set_xlabel('Azimuth (columns)', fontsize=10)
    axes[0,1].set_ylabel('Elevation (rows)', fontsize=10)
    plt.colorbar(im2, ax=axes[0,1], label='Intensity')
    
    # Mask channel
    im3 = axes[1,0].imshow(mask_data, cmap='gray', aspect='auto')
    axes[1,0].set_title(f'Validity Mask\n[{mask_data.min()}, {mask_data.max()}]', fontsize=12)
    axes[1,0].set_xlabel('Azimuth (columns)', fontsize=10)
    axes[1,0].set_ylabel('Elevation (rows)', fontsize=10)
    plt.colorbar(im3, ax=axes[1,0], label='Valid (1) / Invalid (0)')
    
    # Combined visualization (range + intensity)
    # Normalize both channels for better visualization
    range_norm = (range_data - range_data.min()) / (range_data.max() - range_data.min() + 1e-8)
    intensity_norm = (intensity_data - intensity_data.min()) / (intensity_data.max() - intensity_data.min() + 1e-8)
    
    # Create RGB image: R=intensity, G=range, B=range
    combined = np.stack([intensity_norm, range_norm, range_norm], axis=-1)
    combined = np.clip(combined, 0, 1)
    
    axes[1,1].imshow(combined, aspect='auto')
    axes[1,1].set_title('Combined Visualization\n(R=intensity, G/B=range)', fontsize=12)
    axes[1,1].set_xlabel('Azimuth (columns)', fontsize=10)
    axes[1,1].set_ylabel('Elevation (rows)', fontsize=10)
    
    plt.suptitle(title, fontsize=16)
    plt.tight_layout()
    
    if save_path:
        plt.savefig(save_path, dpi=150, bbox_inches='tight')
        print(f"Visualization saved to: {save_path}")
    
    plt.show()


def visualize_single_channel(data, channel='range', title="Range Image", save_path=None):
    """Visualize only a single channel"""
    # Handle different data formats
    if isinstance(data, dict):
        if channel == 'range':
            channel_data = data['range']
            cmap = 'viridis'
            label = 'Range (m)'
        elif channel == 'intensity':
            channel_data = data['intensity']
            cmap = 'plasma'
            label = 'Intensity'
        elif channel == 'mask':
            channel_data = data.get('mask', np.ones_like(data['range'], dtype=np.uint8))
            cmap = 'gray'
            label = 'Valid (1) / Invalid (0)'
        else:
            raise ValueError(f"Unknown channel: {channel}")
    else:
        # Fallback for old format
        if channel == 'range':
            channel_data = data[:, :, 0]
            cmap = 'viridis'
            label = 'Range (m)'
        elif channel == 'intensity':
            channel_data = data[:, :, 1]
            cmap = 'plasma'
            label = 'Intensity'
        else:
            raise ValueError(f"Channel {channel} not available in old format")
    
    # Create single plot with only the chosen channel
    fig, ax = plt.subplots(1, 1, figsize=(12, 8))
    
    im = ax.imshow(channel_data, cmap=cmap, aspect='auto')
    ax.set_title(f'{title}\n{channel.capitalize()} Channel [{channel_data.min():.3f}, {channel_data.max():.3f}]', fontsize=14)
    ax.set_xlabel('Azimuth (columns)', fontsize=12)
    ax.set_ylabel('Elevation (rows)', fontsize=12)
    
    # Add colorbar
    cbar = plt.colorbar(im, ax=ax, label=label)
    cbar.ax.tick_params(labelsize=10)
    
    # Customize ticks
    ax.tick_params(axis='both', which='major', labelsize=10)
    
    plt.tight_layout()
    
    if save_path:
        plt.savefig(save_path, dpi=150, bbox_inches='tight')
        print(f"Visualization saved to: {save_path}")
    
    plt.show()


def visualize_multiple_samples(data_dir, num_samples=3, save_dir=None, channel='range'):
    """Visualize multiple random samples from the dataset"""
    # Find all .npy files
    npy_files = glob.glob(os.path.join(data_dir, "*.npy"))
    
    if not npy_files:
        print(f"No .npy files found in {data_dir}")
        return
    
    print(f"Found {len(npy_files)} samples in {data_dir}")
    
    # Randomly sample files
    if num_samples > len(npy_files):
        num_samples = len(npy_files)
        print(f"Only {num_samples} samples available")
    
    selected_files = np.random.choice(npy_files, num_samples, replace=False)
    
    for i, file_path in enumerate(selected_files):
        print(f"\n--- Sample {i+1}/{num_samples} ---")
        print(f"File: {os.path.basename(file_path)}")
        
        try:
            data = load_range_image(file_path)
            
            title = f"nuScenes Range Image - {os.path.basename(file_path)}"
            
            if save_dir:
                save_path = os.path.join(save_dir, f"sample_{i+1:02d}_{channel}.png")
                visualize_single_channel(data, channel, title, save_path)
            else:
                visualize_single_channel(data, channel, title)
                
        except Exception as e:
            print(f"Error processing {file_path}: {e}")
            continue


def main():
    parser = argparse.ArgumentParser(description="Visualize nuScenes range images")
    parser.add_argument("--data_dir", type=str, required=True, 
                       help="Directory containing .npy files")
    parser.add_argument("--sample_index", type=int, default=None,
                       help="Specific sample index to visualize (e.g., 0 for 00000000.npy)")
    parser.add_argument("--num_samples", type=int, default=3,
                       help="Number of random samples to visualize (if not using --sample_index)")
    parser.add_argument("--save_dir", type=str, default=None,
                       help="Directory to save visualizations (optional)")
    parser.add_argument("--save_name", type=str, default=None,
                       help="Name for saved visualization (if visualizing single sample)")
    parser.add_argument("--channel", type=str, default='range', choices=['range', 'intensity', 'mask', 'all'],
                       help="Channel to visualize (or 'all' for multi-panel view)")
    parser.add_argument("--multi_panel", action='store_true', default=False,
                       help="Show multi-panel visualization (range, intensity, mask, combined)")
    
    args = parser.parse_args()
    
    if not os.path.exists(args.data_dir):
        print(f"Error: Data directory does not exist: {args.data_dir}")
        return
    
    # Create save directory if specified
    if args.save_dir:
        Path(args.save_dir).mkdir(parents=True, exist_ok=True)
    
    if args.sample_index is not None:
        # Visualize specific sample
        sample_file = os.path.join(args.data_dir, f"{args.sample_index:08d}.npy")
        
        if not os.path.exists(sample_file):
            print(f"Error: Sample file not found: {sample_file}")
            return
        
        print(f"Visualizing sample {args.sample_index:08d}")
        data = load_range_image(sample_file)
        
        title = f"nuScenes Range Image - Sample {args.sample_index:08d}"
        
        # Only show multi-panel if explicitly requested
        if args.multi_panel or args.channel == 'all':
            if args.save_name:
                save_path = os.path.join(args.save_dir or ".", args.save_name)
                visualize_range_image(data, title, save_path)
            else:
                visualize_range_image(data, title)
        else:
            # Default to single channel view
            if args.save_name:
                save_path = os.path.join(args.save_dir or ".", args.save_name)
                visualize_single_channel(data, args.channel, title, save_path)
            else:
                visualize_single_channel(data, args.channel, title)
            
    else:
        # Visualize multiple random samples - always single channel
        if args.multi_panel or args.channel == 'all':
            print("Multi-panel visualization not supported for multiple samples. Use --sample_index for multi-panel view.")
            return
        visualize_multiple_samples(args.data_dir, args.num_samples, args.save_dir, args.channel)


if __name__ == "__main__":
    main()
